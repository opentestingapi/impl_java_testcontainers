package com.example.demo.systemtest.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;

import com.example.demo.common.Sleeper;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.AbstractEnvironment;
import org.springframework.core.env.Environment;
import org.springframework.core.env.MapPropertySource;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.ClassPathResource;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Map.Entry;

/**
 * this class will wrap the test case execution from definition
 */
@Slf4j
@Testcontainers
@SuppressWarnings("rawtypes")
public abstract class OpenTestingApiTester {

    private final int SLEEPTIMEMS = 5000;    

    private ObjectMapper objectMapper = new ObjectMapper();
    private ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());

    private HttpClient client = HttpClient.newBuilder().build();

    private static String opentestingurl = "http://docker:50000/";

    @Autowired
	private Environment env;

    //test case replacements
    private Map<String, Object> replacements = null;
    
    //reporting
    @Getter
    private static int summary_all = 0;
    @Getter
    private static int summary_success = 0;
    @Getter
    private static int summary_failed = 0;
    @Getter
    private static boolean summary_mandatorySuccess = true;
    @Getter
    private static boolean summary_allSuccess = true;

    @Getter
    @Setter
    public class OTATestResult {
        String testName;
        String checkName;
        String Description;
        Boolean result;
    }
    // Test -> [Check/Description/Result]
    @Getter
    private static List<OTATestResult> testResults = new ArrayList<>();

    private Map<String, Object> getReplacements() {
        if (replacements == null) { 
            // add properties as replacements
            replacements = Collections.synchronizedMap(new HashMap<>());
            for(Iterator it = ((AbstractEnvironment) env).getPropertySources().iterator(); it.hasNext(); ) {
                PropertySource propertySource = (PropertySource) it.next();
                if (propertySource instanceof MapPropertySource) {
                    replacements.putAll(((MapPropertySource) propertySource).getSource());
                }
            }
        }
        return replacements;
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * a default configuration
     *
     * @param folderWithFiles
     * @return
     * @throws IOException
     * @throws InterruptedException
     */
    public boolean testDefault(String folderWithFiles) throws IOException, InterruptedException {

        //test specified?
        String testFile = "notavailable";
        if (folderWithFiles.endsWith(".yml") || folderWithFiles.endsWith(".json")) {
            testFile = folderWithFiles;
            folderWithFiles = folderWithFiles.substring(0, folderWithFiles.lastIndexOf("/"));
        }

        //default files
        if (!new ClassPathResource(testFile).exists()) testFile = folderWithFiles +"/test.yml";
        if (!new ClassPathResource(testFile).exists()) testFile = folderWithFiles +"/test.json";

        //check foldername
        String foldername = folderWithFiles.substring(folderWithFiles.lastIndexOf("/")+1);
        if (!new ClassPathResource(testFile).exists()) testFile = folderWithFiles +"/"+foldername+".json";
        if (!new ClassPathResource(testFile).exists()) testFile = folderWithFiles +"/"+foldername+".yml";

        if (!folderWithFiles.endsWith("/")) folderWithFiles = folderWithFiles + "/";
        log.info("testFile: "+testFile);
        log.info("folderWithFiles: "+folderWithFiles);

        JsonNode testCase = getJsonNode(testFile);

        JsonNode id = testCase.findValue("id");
        List<String> injects = new ArrayList<>();

        //for (JsonNode inject : testCase.findValues("injectid"))
        //    injects.add(id.textValue() + "." + inject.textValue());
        JsonNode inject = testCase.findValues("injectid").get(0);
        injects.add(id.textValue() + "." + inject.textValue());

        return test(testFile, folderWithFiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        URL url = getClass().getClassLoader().getResource(folderwithfiles);
        String path = url.getPath();
        for (File f : new File(path).listFiles()) {
            if (f.isFile()) {
                log.info("upload: "+f.toURI().toURL().toString());
                URL e = f.toURI().toURL();
                urls.add(e);
            }
            //add files in folder named like test case
            if (f.isDirectory() && (testfile.contains(f.getName()) || f.getName().equalsIgnoreCase("testdata"))) {
                for (File f2 : f.listFiles()) {
                    log.info("upload: "+f2.toURI().toURL().toString());
                    urls.add(f2.toURI().toURL());
                }
            } 
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        for (String f : files) {
            urls.add(getClass().getClassLoader().getResource(f));
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        String path = folderwithfiles.getPath();
        for (File f : new File(path).listFiles()) {
            if (f.isFile()) {
                log.info("upload: "+f.toURI().toURL().toString());
                urls.add(f.toURI().toURL());
            }
            //add files in folder named like test case
            if (f.isDirectory() && (testfile.getPath().contains(f.getName()) || f.getName().equalsIgnoreCase("testdata"))) {
                for (File f2 : f.listFiles()) {
                    log.info("upload: "+f2.toURI().toURL().toString());
                    urls.add(f2.toURI().toURL());
                }
            }   
        }

        return test(testfile, urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //read test case
        String testcase = this.getResourceContent(testfile, true);

        //read attributes
        JsonNode testcasemap = getJsonNode(testfile);
        String id = testcasemap.findValue("id").textValue();

        // upload test case files
        HttpRequest request;
        HttpResponse<String> response;        
        for (URL file : files) {
            request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(getResourceContent(file, false)))
                    .uri(URI.create(opentestingurl + "upload/file/"+id+"/"+Paths.get(file.getPath()).getFileName().toString()))
                    .header("Content-Type", "application/json")
                    .build();
            response = client.send(request, HttpResponse.BodyHandlers.ofString());
            log.debug(file.getFile()+ ": " + response.body());
        }

        // upload test case
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(testcase))
                .uri(URI.create(opentestingurl + "upload/test"))
                .header("Content-Type", "application/json")
                .build();
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug(testfile.getFile()+ ": " + response.body());

        // start bulk execution
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(this.objectMapper.writeValueAsString(injects)))
                .uri(URI.create(opentestingurl + "trigger/bulk"))
                .header("Content-Type", "application/json")
                .build();
        log.debug("Bulkrequest " + request.uri());
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug("opentesting trigger bulk: " + response.body());

        if(response.body().contains("invalid"))
            return false;

        // read bulkid from result
        JsonNode opentestingdata = objectMapper.createObjectNode();

        JsonNode bulkIdRoot = json2JsonNode(response.body());
        String bulkid = bulkIdRoot.findValue("bulkid").textValue();

        // wait for the test case result - there should not be open test cases anymore:
        // "percentage":0.0,"all":1,"success":0,"open":1,"failed":0,"mandatorySuccess":false,"allSuccess":false
        int openchecks = 1;

        String result = "";
        while (openchecks > 0) {
            Sleeper.sleep(SLEEPTIMEMS);
            result = getBulkResult(bulkid);
            opentestingdata = json2JsonNode(result);
            openchecks = opentestingdata.findValue("open").asInt();
        }
        log.debug("opentesting bulk result: " + result);

        // validation
        boolean mandatorySuccess = opentestingdata.findValue("mandatorySuccess").asBoolean();
        if (!mandatorySuccess) summary_mandatorySuccess = false;
        boolean allSuccess = opentestingdata.findValue("allSuccess").asBoolean();
        if (!allSuccess) summary_allSuccess = false;
        summary_all += opentestingdata.findValue("all").asInt();
        summary_success += opentestingdata.findValue("success").asInt();
        summary_failed += opentestingdata.findValue("failed").asInt();

        // more detailed
        JsonNode checks = opentestingdata.findValue("checks");
        Iterator<JsonNode> check = checks.elements();
        while(check.hasNext()){
            JsonNode next = check.next();

            OTATestResult testResult = new OTATestResult();
            testResult.setTestName(id);
            testResult.setCheckName( next.findValue("checkid").textValue());
            JsonNode description = next.findValue("description"); //optional
            if (description != null) testResult.setDescription(description.textValue());
            testResult.setResult(next.findValue("success").asBoolean());
            testResults.add(testResult);
        }

        if (mandatoryonly) {
            if (!allSuccess) {
                log.warn("some non-mandatory checks failed: " + opentestingdata.findValue("failed").asInt());
            }
            return mandatorySuccess;
        } else {
            return allSuccess;
        }
    }

    /**
     * request bulk result by bulkid
     *
     * @param bulkid Bulk ID
     * @return the result of the bulk
     * @throws InterruptedException
     * @throws IOException
     */
    private String getBulkResult(String bulkid) throws IOException, InterruptedException {

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(opentestingurl + "reporting/bulk?bulkid=" + bulkid))
                .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug("opentesting bulk result: " + response.body());

        return response.body();
    }

    /**
     * read file content from resources folder and replace properties
     *
     * @param filename name of the file
     * @return file content
     * @throws IOException
     */
    private String getResourceContent(URL filename, boolean replace) throws IOException {
        log.info("reading: "+filename.getFile());
        InputStream in = filename.openStream();
        //replace all properties in test case
        try (Scanner s = new Scanner(in).useDelimiter("\\A")) {
            String content = s.hasNext() ? s.next() : "";
            if (replace) {
                for (Entry<String,Object> repl : getReplacements().entrySet()) {
                    content = content.replace("${"+repl.getKey()+"}", ""+repl.getValue());
                }
                //write file for download
                if (!filename.getFile().contains("generated_")) {
                    String filepath = filename.getFile();
                    int lastslash = filepath.lastIndexOf("/");
                    filepath = filepath.substring(0, lastslash)+"/generated_"+filepath.substring(lastslash+1);
                    log.info("writing: "+filepath);
                    FileWriter output = new FileWriter(filepath);
                    output.append(content);
                    output.flush();
                    output.close();
                }
            }
            return content;
        }
    }

    /**
     * Json string to JsonNode
     *
     * @param input json input
     * @return JsonNode
     * @throws JsonProcessingException
     */
    public JsonNode json2JsonNode(String input) throws JsonProcessingException {
        return objectMapper.readTree(input);
    }

    /**
     * map from Json string using JsonNode
     *
     * @param input json input
     * @return map with attributes
     * @throws JsonProcessingException
     */
    public Map<String, Object> json2Map(String input) throws JsonProcessingException {
        return objectMapper.convertValue(json2JsonNode(input), new TypeReference<Map<String, Object>>() {
        });
    }

    private JsonNode getJsonNode(String filename, InputStream content) throws IOException {
        JsonNode testCase = null;       
        if (filename.toLowerCase().endsWith("yml")) {
            testCase = yamlReader.readTree(content);
        } else {
            testCase = objectMapper.readTree(content);
        }
        return testCase;
    }

    private JsonNode getJsonNode(URL testfile) throws IOException {
        return getJsonNode(testfile.getFile(), new ByteArrayInputStream(this.getResourceContent(testfile, true).getBytes()));
    }

    private JsonNode getJsonNode(String fileInCLasspath) throws IOException {
        return getJsonNode(fileInCLasspath, new ClassPathResource(fileInCLasspath).getInputStream());
    }

}
