package com.example.demo.reusable;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.*;
import java.net.URI;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * this class will wrap the test case execution from definition
 */
public class OpenTestingApiExec {

    private final int SLEEPTIMEMS = 5000;

    private final static Logger LOG = Logger.getLogger(OpenTestingApiExec.class.getName());

    private ObjectMapper objectMapper = new ObjectMapper();

    private HttpClient client = HttpClient.newBuilder().build();

    private String opentestingurl;

    /**
     * create the execution component
     *
     * @param opentestingurl URL of the opentesting container, http://servername:port/
     */
    public OpenTestingApiExec(String opentestingurl) {
        this.opentestingurl = opentestingurl;

        //fix ending
        if (!this.opentestingurl.endsWith("/")) this.opentestingurl = this.opentestingurl + "/";
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        URL url = getClass().getClassLoader().getResource(folderwithfiles);
        String path = url.getPath();
        for (File f : new File(path).listFiles()) {
            urls.add(f.toURI().toURL());
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        for (String f : files) {
            urls.add(getClass().getClassLoader().getResource(f));
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        String path = folderwithfiles.getPath();
        for (File f : new File(path).listFiles()) {
            urls.add(f.toURI().toURL());
        }

        return test(testfile, urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //read test case
        String testcase = this.getResourceContent(testfile);

        //read attributes
        Map<String,Object> testcasemap = this.json2Map(testcase);
        String id = (String) testcasemap.get("id");

        // upload test case files
        HttpRequest request;
        HttpResponse<String> response;
        for (URL file : files) {
            request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(getResourceContent(file)))
                    .uri(URI.create(opentestingurl + "upload/file/"+id+"/"+Paths.get(file.getPath()).getFileName().toString()))
                    .header("Content-Type", "application/json")
                    .build();
            response = client.send(request, HttpResponse.BodyHandlers.ofString());
            LOG.info(file.getFile()+ ": " + response.body());
        }

        // upload test case
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(testcase))
                .uri(URI.create(opentestingurl + "upload/test"))
                .header("Content-Type", "application/json")
                .build();
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        LOG.info(testfile.getFile()+ ": " + response.body());

        // start bulk execution
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(this.objectMapper.writeValueAsString(injects)))
                .uri(URI.create(opentestingurl + "trigger/bulk"))
                .header("Content-Type", "application/json")
                .build();
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        LOG.info("opentesting trigger bulk: " + response.body());

        // read bulkid from result
        Map<String, Object> opentestingdata = json2Map(response.body());
        String bulkid = (String) opentestingdata.get("bulkid");

        // wait for the test case result - there should not be open test cases anymore:
        // "percentage":0.0,"all":1,"success":0,"open":1,"failed":0,"mandatorySuccess":false,"allSuccess":false
        int openchecks = 1;
        String result = "";
        while (openchecks > 0) {
            Thread.sleep(SLEEPTIMEMS);
            result = getBulkResult(bulkid);
            opentestingdata = json2Map(result);
            openchecks = (Integer) opentestingdata.get("open");
        }
        LOG.info("opentesting bulk result: " + result);

        // validation
        boolean mandatorySuccess = (Boolean) opentestingdata.get("mandatorySuccess");
        boolean allSuccess = (Boolean) opentestingdata.get("allSuccess");
        if (mandatoryonly) {
            if (!allSuccess) {
                LOG.log(Level.WARNING, "some non-mandatory checks failed: " + opentestingdata.get("failed"));
            }
            return mandatorySuccess;
        } else {
            return allSuccess;
        }
    }

    /**
     * request bulk result by bulkid
     *
     * @param bulkid Bulk ID
     * @return the result of the bulk
     * @throws InterruptedException
     * @throws IOException
     */
    private String getBulkResult(String bulkid) throws IOException, InterruptedException {

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(opentestingurl + "reporting/bulk?bulkid=" + bulkid))
                .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        LOG.log(Level.FINE, "opentesting bulk result: " + response.body());

        return response.body();
    }

    /**
     * read file content from resources folder
     *
     * @param filename name of the file
     * @return file content
     * @throws IOException
     */
    private String getResourceContent(URL filename) throws IOException {
        BufferedInputStream is = new BufferedInputStream(filename.openStream());
        return new String(is.readAllBytes(), StandardCharsets.UTF_8);
    }

    /**
     * Json string to JsonNode
     *
     * @param input json input
     * @return JsonNode
     * @throws JsonProcessingException
     */
    public JsonNode json2JsonNode(String input) throws JsonProcessingException {
        return objectMapper.readTree(input);
    }

    /**
     * map from Json string using JsonNode
     *
     * @param input json input
     * @return map with attributes
     * @throws JsonProcessingException
     */
    public Map<String, Object> json2Map(String input) throws JsonProcessingException {
        return objectMapper.convertValue(json2JsonNode(input), new TypeReference<Map<String, Object>>() {
        });
    }

}